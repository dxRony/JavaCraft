package olc1_vj24_3363565520917.backend.analisis;

//importaciones 
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import olc1_vj24_3363565520917.backend.abstracto.Instruccion;
import olc1_vj24_3363565520917.backend.simbolo.Tipo;
import olc1_vj24_3363565520917.backend.simbolo.tipoDato;

//instrucciones
import olc1_vj24_3363565520917.backend.instrucciones.Print;

//expresiones
import olc1_vj24_3363565520917.backend.expresiones.Nativo;
import olc1_vj24_3363565520917.backend.expresiones.Aritmeticas;
import olc1_vj24_3363565520917.backend.expresiones.OperadoresAritmeticos;


//definiendo el parser
parser code
{:
    scanner s;
    parser(scanner s) {this.s = s;}
    
    public void syntax_error(Symbol s){
        System.out.println("Error Sintactico en la linea " + 
        (s.left) + " y columna " + (s.right) +
        ". No se esperaba el componente: " + (s.value) + ".");
    }

    public void unrecovered_syntax_error(Symbol s ){
        System.out.println("Error Sintactico no recuperable en la linea" +
        (s.left) + " y columna " + (s.right) +
        ". No se esperaba el componente: " + (s.value) + ".");
    }
:}

action code 
{:   
    //String codigoUsr = "";                                              //aca se guarda el codigo del usuario

:}
                                                                        //terminales: los que no generan una produccion en la gramatica
terminal String CADENA, ENTERO, DECIMAL;                                //se define como string para poder acceder a su valor posteriormente//no se les pone tipo para los que no interesa saber el valor
terminal FININSTRUCCION, IMPRIMIR, MAS, MENOS, MULTI, DIV, PAR1, PAR2, UMENOS, VAR, CONST, INT, DOUBLE, BOOL, TRUE, FALSE;
terminal CHAR, STRING, IF, ELSE, MATCH, WHILE, FOR, DO, BREAK,IGUALACION, POTENCIA, DIFERENCIACION, MENORIGUALQUE, MAYORIGUALQUE;
terminal OR, AND, XOR, NOT, INCREMENTO, DECREMENTO, ASIGNACION, MODULO, DEFAULT, MENORQUE, MAYORQUE, CORCH1, CORCH2;

//todos los no terminales van a ser una instruccion
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion EXPRESION;

precedence left MAS;
precedence left UMENOS;                                                 //la precedencia va de abajo hacia arriba 

start with INICIO;                                                      //se inicia con INICIO

INICIO ::= INSTRUCCIONES:a  {:      RESULT=a;      :}  //inicio produce INSTRUCCIONES
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b   {:  RESULT= a; RESULT.add(b);                    :}                        //instrucciones produce una lista de instrucciones o una sola INSTRUCCION
                | INSTRUCCION:a                   {: RESULT = new LinkedList<>(); RESULT.add(a);   :}
;
//public Print(int linea, int columna, Instruccion expresion){}
INSTRUCCION ::= IMPRIMIR PAR1 EXPRESION:a PAR2 FININSTRUCCION   {: RESULT = new Print(aleft, aright, a); :}        
;
//public Aritmeticas(int linea, int columna, OperadoresAritmeticos operacion, Instruccion operandoUnico) {}
//public Aritmeticas(int linea, int columna, Instruccion operando1, Instruccion operando2, OperadoresAritmeticos operacion) {
//public Nativo(Tipo tipo, int linea, int columna, Object valor){}
EXPRESION ::= MENOS EXPRESION:a           {:  RESULT = new Aritmeticas(aleft, aright, OperadoresAritmeticos.NEGACION, a);   :}%prec UMENOS
            | EXPRESION:a MAS EXPRESION:b {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.SUMA);    :}
            | ENTERO:a      {:  RESULT = new Nativo(new Tipo(tipoDato.ENTERO), aleft, aright, Integer.parseInt(a));         :}   //se puede parsear aca o en la clase nativo
            | DECIMAL:a     {:  RESULT = new Nativo(new Tipo(tipoDato.DECIMAL), aleft, aright, new Double(a));              :}
            | CADENA:a      {:  RESULT = new Nativo(new Tipo(tipoDato.CADENA), aleft, aright, a);                           :}
;
//1:38
