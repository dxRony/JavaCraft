package olc1_vj24_3363565520917.backend.analisis;

//importaciones 
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import olc1_vj24_3363565520917.backend.abstracto.Instruccion;
import olc1_vj24_3363565520917.backend.simbolo.Tipo;
import olc1_vj24_3363565520917.backend.simbolo.tipoDato;
import olc1_vj24_3363565520917.backend.excepciones.Errores;

//instrucciones
import olc1_vj24_3363565520917.backend.instrucciones.Print;
import olc1_vj24_3363565520917.backend.instrucciones.Declaracion;
import olc1_vj24_3363565520917.backend.instrucciones.AsignacionVar;


//expresiones
import olc1_vj24_3363565520917.backend.expresiones.Nativo;
import olc1_vj24_3363565520917.backend.expresiones.Aritmeticas;
import olc1_vj24_3363565520917.backend.expresiones.Relacionales;
import olc1_vj24_3363565520917.backend.expresiones.Logicos;
import olc1_vj24_3363565520917.backend.expresiones.OperadoresAritmeticos;
import olc1_vj24_3363565520917.backend.expresiones.OperadoresRelacionales;
import olc1_vj24_3363565520917.backend.expresiones.OperadoresLogicos;
import olc1_vj24_3363565520917.backend.expresiones.AccesoVar;


//definiendo el parser
parser code
{:
    scanner s;
    parser(scanner s) {this.s = s;}

    public LinkedList<Errores> listaErrores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        listaErrores.add(new Errores("SINTACTICO RECUPERABLE", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

    public void unrecovered_syntax_error(Symbol s ){
        listaErrores.add(new Errores("SINTACTICO NO RECUPERABLE", "No se esperaba el componente: " + s.value, s.left, s.right));
    }
:}

action code 
{:   
    //String codigoUsr = "";                                              //aca se guarda el codigo del usuario

:}
                                                                        //terminales: los que no generan una produccion en la gramatica
terminal String CADENA, ENTERO, DECIMAL, CARACTER, BOOLEANO, ID;            //se define como string para poder acceder a su valor posteriormente//no se les pone tipo para los que no interesa saber el valor
terminal FININSTRUCCION, IMPRIMIR, MAS, MENOS, MULTIPLICAR, DIVIDIR, PAR1, PAR2, UMENOS, VAR, CONST, INT, DOUBLE, BOOL;
terminal CHAR, STRING, IF, ELSE, MATCH, WHILE, FOR, DO, BREAK, IGUALACION, POTENCIA, DIFERENCIACION, MENORIGUALQUE, MAYORIGUALQUE;
terminal OR, AND, XOR, NOT, INCREMENTO, DECREMENTO, IGUAL, MODULO, DEFAULT, MENORQUE, MAYORQUE, CORCH1, CORCH2;

//todos los no terminales van a ser una instruccion
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion EXPRESION, DECLARACION, ASIGNACION, IMPRESION;
nonterminal Tipo TIPOS;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left IGUALACION, DIFERENCIACION, MENORQUE, MENORIGUALQUE, MAYORQUE, MAYORIGUALQUE;
precedence left MAS, MENOS;
precedence left MULTIPLICAR, DIVIDIR, MODULO;
precedence nonassoc POTENCIA;
precedence right UMENOS;                                                 //la precedencia va de abajo hacia arriba 

start with INICIO;                                                      //se inicia con INICIO

INICIO ::= INSTRUCCIONES:a  {:      RESULT=a;      :}  
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b   {:  RESULT= a; RESULT.add(b);                    :}                        //instrucciones produce una lista de instrucciones o una sola INSTRUCCION
                | INSTRUCCION:a                   {: RESULT = new LinkedList<>(); RESULT.add(a);   :}
;

INSTRUCCION ::= IMPRESION:a             {:  RESULT=a;    :}
            | DECLARACION:a             {:  RESULT=a;    :}
            | ASIGNACION:a              {:  RESULT=a;    :}
            | error FININSTRUCCION
            | error        
;

IMPRESION ::= IMPRIMIR PAR1 EXPRESION:a PAR2 FININSTRUCCION   {:    RESULT = new Print(aleft, aright, a);   :}
;

DECLARACION ::= TIPOS:a ID:b IGUAL EXPRESION:c FININSTRUCCION {:    RESULT = new Declaracion(a, aleft, aright, b, c);  :}
;
// public AsignacionVar(String id, Instruccion exp, int linea, int columna){
ASIGNACION ::= ID:a IGUAL EXPRESION:b FININSTRUCCION          {:    RESULT = new AsignacionVar(a, b, aleft, aright);      :}
;

TIPOS ::= INT       {:  RESULT = new Tipo(tipoDato.ENTERO);   :}
        | DOUBLE    {:  RESULT = new Tipo(tipoDato.DECIMAL);  :}
        | STRING    {:  RESULT = new Tipo(tipoDato.CADENA);   :}
        | CHAR      {:  RESULT = new Tipo(tipoDato.CARACTER); :}
        | BOOL      {:  RESULT = new Tipo(tipoDato.BOOLEANO); :}
;
            //inicio aritmeticas
EXPRESION ::= MENOS EXPRESION:a                         {:  RESULT = new Aritmeticas(aleft, aright, OperadoresAritmeticos.NEGACION, a);              :}%prec UMENOS
            | EXPRESION:a MAS EXPRESION:b               {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.SUMA);               :}
            | EXPRESION:a MENOS EXPRESION:b             {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.RESTA);              :}
            | EXPRESION:a MULTIPLICAR EXPRESION:b       {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.MULTIPLICACION);     :}
            | EXPRESION:a DIVIDIR EXPRESION:b           {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.DIVISION);           :}
            | EXPRESION:a POTENCIA EXPRESION:b          {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.POTENCIA);           :}
            | EXPRESION:a MODULO EXPRESION:b            {:  RESULT = new Aritmeticas(aleft, aright, a, b, OperadoresAritmeticos.MODULO);             :}
            | EXPRESION:a IGUALACION EXPRESION:b        {:  RESULT = new Relacionales(aleft, aright, a, b, OperadoresRelacionales.IGUALACION);       :}
            | EXPRESION:a DIFERENCIACION EXPRESION:b    {:  RESULT = new Relacionales(aleft, aright, a, b, OperadoresRelacionales.DIFERENCIACION);   :}
            | EXPRESION:a MENORQUE EXPRESION:b          {:  RESULT = new Relacionales(aleft, aright, a, b, OperadoresRelacionales.MENORQUE);         :}
            | EXPRESION:a MENORIGUALQUE EXPRESION:b     {:  RESULT = new Relacionales(aleft, aright, a, b, OperadoresRelacionales.MENORIGUALQUE);    :}
            | EXPRESION:a MAYORQUE EXPRESION:b          {:  RESULT = new Relacionales(aleft, aright, a, b, OperadoresRelacionales.MAYORQUE);         :}
            | EXPRESION:a MAYORIGUALQUE EXPRESION:b     {:  RESULT = new Relacionales(aleft, aright, a, b, OperadoresRelacionales.MAYORIGUALQUE);    :}
            | NOT EXPRESION:a                           {:  RESULT = new Logicos(aleft, aright, OperadoresLogicos.NOT, a);                           :}%prec NOT
            | EXPRESION:a OR EXPRESION:b                {:  RESULT = new Logicos(aleft, aright, a, b, OperadoresLogicos.OR);                         :}
            | EXPRESION:a AND EXPRESION:b               {:  RESULT = new Logicos(aleft, aright, a, b, OperadoresLogicos.AND);                        :}
            | EXPRESION:a XOR EXPRESION:b               {:  RESULT = new Logicos(aleft, aright, a, b, OperadoresLogicos.XOR);                        :}
            | PAR1 EXPRESION:a PAR2                     {:  RESULT = a;                                                                              :}
            | ENTERO:a                                  {:  RESULT = new Nativo(new Tipo(tipoDato.ENTERO), aleft, aright, Integer.parseInt(a));      :}//se puede parsear aca o en la clase nativo
            | DECIMAL:a                                 {:  RESULT = new Nativo(new Tipo(tipoDato.DECIMAL), aleft, aright, new Double(a));           :}
            | CADENA:a                                  {:  RESULT = new Nativo(new Tipo(tipoDato.CADENA), aleft, aright, a);                        :}
            | CARACTER:a                                {:  RESULT = new Nativo(new Tipo(tipoDato.CARACTER), aleft, aright, a);                      :}
            | BOOLEANO:a                                {:  RESULT = new Nativo(new Tipo(tipoDato.BOOLEANO), aleft, aright, a);                      :}
            | ID:a                                      {:  RESULT = new AccesoVar(aleft, aright, a);                                                :}
;